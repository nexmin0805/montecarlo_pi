


<CUDA로 몬테카를로 알고리즘 구현하기>

1. 몬테카를로 알고리즘이란?
2. 몬테카를로 알고리즘을 이용하여 원주율 값 구하기
3. 병렬분산프로그래밍을 활용한 원주율 값 구하기
4. 결론













몬테카를로 알고리즘이란?
반복된 무작위 추출(repeated random sampling)을 이용하여 함수의 값을 수리적으로 근사하는 알고리즘을 부르는 용어이다. 수학이나 물리학 등에 자주 사용되며, 계산하려는 값이 닫힌 형식으로 표현되지 않거나 복잡한 경우에 근사적으로 계산할 때 사용된다.

몬테카를로 알고리즘을 이용하여 원주율 값 구하기

한 변의 길이가 1인 정사각형이 있다고 가정했을 때,
 
반지름이 1인 원을 4등분 한 원의 면적은 "π/4"이다.
원점(0, 0)에서 특정 점까지의 거리는 피타고라스 정리에 √(x^(2 )+  y^2   ) 으로 표시된다.
원점에서 특정 점까지의 거리가 1 이하면 원 이내에 있다는 것을 알 수 있다.
원의 넓이는 원점과의 거리가 1이하인 점들의 개수를 전체 점들의 개수로 나누어 구할 수 있다.
만약 100개의 다트를 던졌을 때 이 중 80개의 다트가 부채꼴 내부에 맞았다면 π/4 = 80/100 이 된다.
이때 π=3.2 이다. 실제 π의 값은 아니지만 실제값에 근사한 값인 것을 확인할 수 있다.
다트 n개를 던졌다고 가정하고, 이중 m개의 다트가 부채꼴 내부에 맞았다고 가정하면 
π=(4*m)/n이라는 식을 얻을 수 있다. 
즉, 한변의 길이가 1인 사각형 내부에 무작위 좌표의 점을 반복적으로 생성하고, 총 점의 개수와 부채꼴 내부의 점의 개수를 이용하여 π에 근사한 값을 얻을 수 있다.














10억개의 점을 찍었을 때의 코드이다. 소요시간 계산은 수업시간에 배운 gettimeofday함수를 사용하여 출력해주었다. 
위 프로그램을 실행하면 아래와 같은 결과를 얻을 수 있다. n은 점의 개수이다.

<n=1억: 1.787944초>
 




<n=10억: 18.286032초>
 

점의 숫자가 많아질수록 시간이 크게 늘어나는 것을 확인할 수 있었다.
이 프로그램을 cuda를 활용하면 시간을 단축시킬 수 있겠다고 생각하여 이 프로젝트를 시작하게 되었다.

3. 병렬분산프로그래밍을 활용한 원주율 값 구하기

-커널 함수
 
원점에서 점까지의 거리가 1보다 작거나 같으면 원 안에 찍힌 점이다.




shared memory를 사용할 때에는 꼭 syncthreads()함수를 사용해주어야 한다. 
shared memory는 global memory의 데이터를 캐시처럼 shared memory에 올린 뒤 사용한다. shared memory에 올리는 작업은 각각의 스레드가 수행한다. 이 때 syncthreads()함수를 사용하여 동기화를 해주지 않으면, 모두 shared memory에 올라오지 않은 상태에서 값을 참조하여 원하지 않는 값을 가져올수 있기 때문이다.


-벡터로 랜덤한 좌표 생성
 

-좌표값을 호스트에서 디바이스에 복사
 
cudaMalloc:
첫 번째 인자는 할당할 메모리를 가리키는 포인터를 입력한다
두 번째 인자로는 할당할 메모리의 크기를 입력한다.

cudaMemcpy:
첫 번째 인자는 복사할 목적지가되는 포인터로 cudaMemcpy() 함수로 할당한 그래픽 메모리의 포인터를 넣는다.
두 번째 인자는 복사할 소스가 되는 포인터로 PC에서 Malloc() 함수로 할당한 메모리의 포인터를 입력한다.

세 번째 인자는 복사할 크기를 지정한다.
네 번째 인자는 복사를 수행할 종류를 넣는데 PC에서 그래픽 카드로 복사할 때는 cudaMemcpyHostToDevice를 사용한다.
다섯 번째 인자는 다음과 같은 종류를 넣을 수 있다. 
 CudaMemcpyHostToHost 	 PC 메모리에서 PC 메모리로 복사 
 CudaMemcpyHostToHoDevice	 PC 메모리에서 그래픽 카드로 복사 
 CudaMemcpyDeviceToHost	 그래픽 카드 메모리에서 그래픽 카드로 복사 
 CudaMemcpyDeviceToDevice	 그래픽 카드 메모리에서 그래픽 카드로 복사 



-커널 호출
 

-디바이스에서 호스트로 복사
 

-메모리 해제
 

-파이 값 = (4*원 안에 찍힌 점의 개수) / (점의 총 개수)
 

4.결론

-점 100개
처음엔 점이 100개일때부터 시작했다. 점의 개수가 적은 이유로 pi의 값이 정확하지 않은 것을 확인할 수 있다. 또한 소요시간을 보면 GPU가 더 느린 것을 확인할 수 있다. 
 


-점 1000개
 3.14와 조금 더 가까운 값을 보여주고는 있지만, 아직도 CPU의 소요시간이 더 빠르다. 


-1000000개
 
지금부터는 CPU를 사용하는 것보다 GPU를 사용하는 것이 더 효율적인 것을 확인할 수 있었다.




-1억개
CPU의 소요시간은 약 2.3초 GPU의 소요시간은 약 0.3초로 2초정도 차이나고있다. 
또한 파이의 값이 실제 값과 매우 근사한 것을 확인 할 수 있다. 


-10억개
CPU의 소요시간은 22초로 훨씬 증가했지만, GPU의 소요시간은 3.4초로 1억개의 점을 찍었을 때보다 3.1초정도밖에 증가하지 않았다.
 


-15억개
 CPU의 소요시간은 약 30초, GPU의 소요시간은 약 5.2초로 25초정도 차이나고있다.
 


이 프로젝트를 하면서 느낀점은 확실히 일정량 이상의 단순계산을 계산해야 하는 코드를 작성할 때에는 GPU를 활용하는 것이 좋다는 것을 알았다.
또한, 번외의 이야기이지만, 분명 점의 개수를 늘려갈 수록 3.141592의 값에 가까이 다가가는 것을 확인할 수 있었다. 
하지만 그 이후 아무리 더 많은 점을 생성하여도 원하는 값에 수렴하지 못하고, 3.141590 ~ 3.141594 사이의 값을 진동하였다. 억 단위의 난수를 발생시켰음에도 불구하고 소수점 5자리까지밖에 구하지 못했다.
c언어에서 제공하는 rand()함수의 범위는 0~21억 4748만 3647이다. 이 말은, 크기가 1인 사각형을 가로 세로 각각 21억 4748만 3647등분을 한 상태에서 다트를 던진 것이다. 
때문에 C언어에서는 rand()함수를 이용하여 무한대에 가까운 점을 발생시킨다고 하더라도 완벽한 파이의 값을 구하는 데에는 한계가 있다.
그래서 기존의 rand()함수에 10억을 곱하여 rand()함수의 범위를 늘려보았다.
그 결과 기존 rand()함수를 이용했을 때보다 값이 더 정교하고, 소수점 5자리까지 구하는데 더 적은 양의 점을 사용했다. 때문에 rand()함수의 범위를 증가시킬수록 파이의 값이 더욱 정밀하게 도출될 것이라고 생각했다.
하지만 그렇지 않았다. 이론상 사각형을 더 잘게 쪼갤수록 더 정밀도 있는 결과가 나와야한다. 그러나 실제로 프로그램을 만들어 실험해 본 결과 예상과는 달리 오히려 범위를 증가시키자 기존의 rand()함수를 사용했을 때 보다도 더 정밀도가 떨어졌다.
그 이유는 rand()함수 범위의 증폭 방법에 있었다. 임의로 rand()함수의 범위를 늘리게 되면 난수 발생의 분포도가 흐트러지게 된다. 쉽게 랜덤으로 발생한 점의 좌표에 쏠림 현상이 발생하게 되고 결국 파이값의 정밀도를 떨어뜨리는 결과를 낳게 된다.
그래서 이번엔 100퍼센트의 분포도일 경우 얼마나 정밀한 파이값을 구할 수 있는지 알아보았다.
아까처럼 한변의 길이가 1인 정사각형에 점을 찍지만, 구역을 변들을 나누고 나눈 변들의 교차점에 점을 찍는 방식으로 접근해 보았다.
사각형을 백만 등분하고 100% 균일하게 점을 찍었을 때 1억까지 갈 필요도 없이 이미 소수 7번째 자리까지 정확한 값을 구할 수 있었다. 
또한 10배씩 범위를 증가시킴에 따라 정밀도가 약 10배씩 증가하는 것을 볼 수 있는데, 사각형을 10의 11제곱에서 12제곱수준의 값으로 나누어 점을 찍으면 소수점 열한자리까지의 정확한 결과를 얻을 수 있을것으로 예상된다.
결과적으로 몬테카를로 알고리즘을 이용하여 원주율을 구하는데 가장 중요한 요건은 난수를 얼마나 많이 발생시키느냐가 아닌 rand()함수가 난수를 얼마나 고르게 발생시키느냐 라는 것을 알 수 있었다. 
이는 원주율을 구할 때 뿐만 아니라 몬테카를로 알고리즘을 이용하여 확률적인 계산을 하는 모든 문제에 있어서 마찬가지로 적용되는 문제라고 보여진다.
이 프로젝트를 시작할 때의 GPU로 조단위의 점을 발생시켜 원주율을 구하면 소수점 몇번째 자리까지의 원주율을 구할 수 있을까라는 기대와는 다른 전혀 다른 결과를 얻었지만,  GPU를 활용하여 단순계산의 소요시간을 대폭 감소시킬 수 있었다는 것을 알 수 있었다. 
또한 몬테카를로 알고리즘을 이용할 때엔 무작정 많은 난수를 발생시키려고 하기보다는 좋은 랜덤함수를 만드는 일이 선행되어야 한다는 결과를 도출할 수 있었다. 
병렬분산시스템 프로젝트인 만큼 원주율의 값의 정밀도를 cuda를 활용하여 높이고 싶었지만 rand()함수를 응용하여 정밀도를 높였다는 점이 아쉽다.

